/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2019-10-24

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include "stm32f10x.h"

/** @addtogroup IO_Toggle
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

//Stale zwiazane z budowa drukarki (kroki, przeliczniki itp)
float stepperFactor = 7.205625;			//dzielnik pozycji enkodera wzgledem krokow na silnik osi Y (w tym momencie 1/4 kroku) @@@@@@@@@
int stepMAX = 14494;					//maksymalna liczba krokow (po dojechaniu do krancowki od strony operatora)
int start_pos = 1598;					//liczba krokow do zrobienia na poczatku druku (1krok 0,03mm)					@@@@@@@@@@
int rozdz_krok = 25;					//czas delaya w dziesiatkach mikrosekund miedzy krokami				@@@@@@@@@@
int rozdz_krok_home = 30;				//czas delaya miedzy krokami w ruchu POZA DRUKIEM

//Zmienne zwiazane z przesuwem
int encoderPosition = 0;				//pozycja wg enkodera drukarki
long oldEncoder = 0;					//stara pozycja enkodera
int stepperPosition = 0;				//pozycja silnika przy zalozeniu niegubienia krokow
int stepperCount = 0;					//na ktorych krokach powinien byc
int oldStepper = 0;

//Timery i countery
int timer_ms = 0;						//timer delaya
int counter = 0;						//czas od wlaczenia
int timer_ms2 = 0;						//timer przerwan
int timer_ASF = 0;						//timer przerwania ASF
int timer_bounce = 0;					//timer debouncingu
int timer_enc = 0;						//timer mierzacy czas od ostatniego sygnalu na enkoderze
int timer_us = 0;						//timer w dziesiatkach mikrosekund
int timer_on = 0;						//opoznienie wlaczenia sie drukarki po nacisnieciu przycisku
int timer_ms3 = 0;						//timer sprawdzajacy ile czasu sa wcisniete przyciski jazdy gora/dol

//Flagi
int encoder_flag = 0;					//stan drukarki po wlaczeniu
int ASF_flag = 0;						//stan ASF
int front_end = 0;						//flaga krancowka od strony operatora
int home_end = 0;						//flaga krancowka home
int y_home_but = 1;						//flaga przycisku Y home
int y_front_but = 1;					//flaga przycisku Y front
int stop_but = 1;						//flaga przycisku STOP
int z_up_but = 1;						//flaga przycisku Z up
int z_down_but = 1;						//flaga przycisku Z down
int up_end = 0;							//flaga krancowki gornej
int down_end = 0;						//flaga krancowki dolnej
int print_state = 0;					//flaga stanu drukarki 1 oznacza, ze epson jest wlaczony, 0, ze wylaczony
int turn_flag = 0;						//flaga wciskania przycisku w epsonie przez mikrokontroler
int laser_flag = 0;						//flaga lasera
int but_flag = 0;						//flaga dluzszego przytrzymania przyciskow z

//Delaye

void delay(int nTime)													//delay w ms
{
	timer_ms = nTime;
	while(timer_ms);
}

void delay_us(int nTime)												//delay w dziesiatkach mikrosekund
{
	timer_us = nTime;
	while(timer_us);
}

// Przerwania

void SysTick_Handler()													//Przerwanie co 1 ms
{
	if (timer_ms)
		timer_ms--;
	if(timer_ms2)
		timer_ms2--;
	if(timer_ms3)
		timer_ms3--;
	if(timer_bounce)
		timer_bounce--;
	counter++;
	if(timer_enc)
		timer_enc--;
	if (timer_on)
		timer_on--;
}

void TIM2_IRQHandler()													//Przerwanie co 10us
{
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
	{
		if (timer_us)
			timer_us--;
		if (timer_ASF)
			timer_ASF--;
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
	}
}

void EXTI15_10_IRQHandler()												//przerwania od przyciskow ruchu i lasera
{
	if (EXTI_GetITStatus(EXTI_Line10))								//laser
	{
		if((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10) == 1))
			laser_flag = 1;
		else
			laser_flag = 0;
		timer_bounce = 100;
		EXTI_ClearITPendingBit(EXTI_Line10);
	}
	if (EXTI_GetITStatus(EXTI_Line11))								//wcisniecie lub puszczenie przycisku Y home
	{
		if(timer_bounce == 0)
		{
			if((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 1))
			{
				y_home_but = 1;
			}
			else
			{
				y_home_but = 0;
			}
			timer_bounce = 100;
		}
		EXTI_ClearITPendingBit(EXTI_Line11);
	}
	if (EXTI_GetITStatus(EXTI_Line12))								//wcisniecie lub puszczenie przycisku Y front
	{
		if(timer_bounce == 0)
		{
			if((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12) == 1))
				y_front_but = 1;
			else
				y_front_but = 0;
			timer_bounce = 100;
		}
		EXTI_ClearITPendingBit(EXTI_Line12);
	}
	if (EXTI_GetITStatus(EXTI_Line13))								//wcisniecie lub puszczenie przycisku STOP
	{
		if(timer_bounce == 0)
		{
			if((GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == 1))
				stop_but = 1;
			else
				stop_but = 0;
			up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);
			down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
			front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
			home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
			y_front_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
			y_home_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);
			z_up_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15);
			z_down_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14);
			timer_bounce = 80;
		}
		EXTI_ClearITPendingBit(EXTI_Line13);
	}
	if (EXTI_GetITStatus(EXTI_Line14))								//wcisniecie lub puszczenie przycisku Z down
	{
		if((GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14) == 1))
			z_down_but = 1;
		else
		{
			z_down_but = 0;
			timer_ms3 = 400;
		}
		timer_bounce = 100;
		EXTI_ClearITPendingBit(EXTI_Line14);
	}
	if (EXTI_GetITStatus(EXTI_Line15))								//wcisniecie lub puszczenie przycisku Z up
	{
		if((GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15) == 1))
			z_up_but = 1;
		else
		{
			z_up_but = 0;
			timer_ms3 = 400;
		}
		timer_bounce = 100;
		EXTI_ClearITPendingBit(EXTI_Line15);
	}
}

void EXTI9_5_IRQHandler()												//enkoder oraz krancowki gorna i dolna
{
	if (EXTI_GetITStatus(EXTI_Line5))								//krancowka gorna
	{
		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5) == 1)
			up_end = 1;
		else
			up_end = 0;
		EXTI_ClearITPendingBit(EXTI_Line5);
	}
	if (EXTI_GetITStatus(EXTI_Line6))								//krancowka dolna
	{
		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6) == 1)
			down_end = 1;
		else
			down_end = 0;
		EXTI_ClearITPendingBit(EXTI_Line6);
	}
	if (counter>500)												//po 15,5s wlacza stan enkodera gotowy do druku
	{																//(zapobiega przerwaniom od enkodera przy wlaczaniu drukarki)
		if (encoder_flag == 0)
		{
			timer_ms2 = 15000;
			encoder_flag = 3;
		}
	}
	if (encoder_flag == 3 && ASF_flag == 1)							//po wlaczeniu sie ASF w stanie gotowym do druku szuka momentu cofniecia sie enkodera
	{																//nastepnie zmienia stan na cofniecie nr 2 i wlacza go po 200ms
		if (EXTI_GetITStatus(EXTI_Line8))
		{
			if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 1) // jesli urosl
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 1) 	//ruch w tyl
				{
					timer_ms2 = 200;
					encoder_flag = 4;
					encoderPosition = 0;
				}
			}
			else
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 0) 	//ruch w tyl
				{
					timer_ms2 = 200;
					encoder_flag = 4;
					encoderPosition = 0;
				}
			}
			EXTI_ClearITPendingBit(EXTI_Line8);
		}
		if (EXTI_GetITStatus(EXTI_Line7))
		{
			if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 1) // jesli urosl
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 0) 	//ruch w tyl
				{
					timer_ms2 = 200;
					encoder_flag = 4;
					encoderPosition = 0;
				}
			}
			else
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 1) 	//ruch w tyl
				{
					timer_ms2 = 200;
					encoder_flag = 4;
					encoderPosition = 0;
				}
			}
			EXTI_ClearITPendingBit(EXTI_Line7);
		}
	}
	if (encoder_flag == 4 && timer_ms2 == 0)								//to co wyzej ponowione (tym razem opoznienie 40ms)
	{
		if (EXTI_GetITStatus(EXTI_Line8))
		{
			if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 1) // jesli urosl
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 1) 	//ruch w tyl
				{
					timer_ms2 = 40;
					encoder_flag = 5;
					encoderPosition = 0;
					stepperCount = 0;
				}
			}
			else
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 0) 	//ruch w tyl
				{
					timer_ms2 = 40;
					encoder_flag = 5;
					encoderPosition = 0;
					stepperCount = 0;
				}
			}
			EXTI_ClearITPendingBit(EXTI_Line8);
		}
		if (EXTI_GetITStatus(EXTI_Line7))
		{
			if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 1) // jesli urosl
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 0) 	//ruch w tyl
				{
					timer_ms2 = 40;
					encoder_flag = 5;
					encoderPosition = 0;
					stepperCount = 0;
				}
			}
			else
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 1) 	//ruch w tyl
				{
					timer_ms2 = 40;
					encoder_flag = 5;
					encoderPosition = 0;
					stepperCount = 0;
				}
			}
			EXTI_ClearITPendingBit(EXTI_Line7);
		}
	}
	if (encoder_flag == 5 && timer_ms2 == 0)									//stan druk, czyli czyta wartosci z enkodera
	{
		if (EXTI_GetITStatus(EXTI_Line8))
		{
			if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 1) // jesli urosl
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 0) 	//ruch w przod
				{
					encoderPosition++;
					timer_enc = 5000;
				}
			}
			else
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 1) 	//ruch w przod
				{
					encoderPosition++;
					timer_enc = 5000;
				}
			}
			EXTI_ClearITPendingBit(EXTI_Line8);
		}
		if (EXTI_GetITStatus(EXTI_Line7))
		{
			if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7) == 1) // jesli urosl
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 1) 	//ruch w przod
				{
					encoderPosition++;
					timer_enc = 5000;
				}
			}
			else
			{
				if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8) == 0) 	//ruch w przod
				{
					encoderPosition++;
					timer_enc = 5000;
				}
			}
			EXTI_ClearITPendingBit(EXTI_Line7);
		}
	}
	EXTI_ClearITPendingBit(EXTI_Line7);
	EXTI_ClearITPendingBit(EXTI_Line8);
}

void EXTI3_IRQHandler()													//przerwanie od krancowki home - dodatkowo zeruje pozycje silnika
{																		//oraz flagi enkodera i ASF jesli weszly zaklocenia
	if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3) == 0)
	{
		home_end = 0;
	}
	if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3) == 1)
	{
		home_end = 1;
		stepperCount = 0;
		stepperPosition = 0;
		if (encoder_flag > 3)
		{
			encoder_flag = 3;
			ASF_flag = 0;
		}
	}
	EXTI_ClearITPendingBit(EXTI_Line3);
}

void EXTI2_IRQHandler()													//przerwanie od krancowki front - zeruje stan ASF i cofa stan enkodera na gotowy do druku
{
	if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2) == 0)
	{
		front_end = 0;
		ASF_flag = 0;
	}
	if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2) == 1)
	{
		front_end = 1;
		ASF_flag = 0;
		if(stepperPosition < 6500)
		{
			stepperPosition = stepMAX;
		}
	}
	if (encoder_flag > 3 && encoderPosition > 110000)
		encoder_flag = 3;
	EXTI_ClearITPendingBit(EXTI_Line2);
}

void EXTI1_IRQHandler()													//wlacznik bistabilny - uruchamia timer wykorzystywany pozniej
{
	if(timer_bounce == 0 && timer_on == 0)								//debouncing
	{
		timer_bounce = 300;
		timer_on = 1500;
	}
	EXTI_ClearITPendingBit(EXTI_Line1);
}

void EXTI0_IRQHandler()													//przerwanie ASF - zmienia stan ASF i ustawia timer przy okreslonych warunkach
{
	if(ASF_flag == 0 && encoder_flag == 3 && timer_ms2 == 0 && z_down_but == 1  && timer_bounce == 0)
	{
		ASF_flag = 3;
		timer_ASF = 100;
	}
	EXTI_ClearITPendingBit(EXTI_Line0);
}

void gpio_init()
{
	GPIO_InitTypeDef gpio;
	TIM_TimeBaseInitTypeDef tim;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	SysTick_Config(SystemCoreClock / 1000);

	GPIO_StructInit(&gpio);

	gpio.GPIO_Pin = GPIO_Pin_0;							//Wejscie od ASF
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOA, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_9;							//Czujnik podczerwieni
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOA, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_10;						//Laser
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOA, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_11;						//Z gora
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOA, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_12;						//Z dol
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOA, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_8;							//M2
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOB, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_9;							//M3
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOB, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_11;						//Przycisk Y home
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOB, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_12;						//Przycisk Y front
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOB, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_0;							//Wyjscie na PE sensor
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_1;							//Wejscie od wlacznika
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_2;							//Krancowka front
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_3;							//Krancowka home
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_5;							//Krancowka up
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_6;							//Krancowka down
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_7;							//Enkoder 2
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_8;							//Enkoder 1
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_9;							//M1
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_10;						//dioda wlacznika drukarki
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_12;						//Wlacznik drukarki
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_13;						//Przycisk STOP
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_14;						//Przycisk Z down
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_15;						//Przycisk Z up
	gpio.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_Init(GPIOC, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_6;							//Y DIR
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOD, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_7;							//Y STP
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOD, &gpio);

	GPIO_ResetBits(GPIOC, GPIO_Pin_0);
	GPIO_ResetBits(GPIOA, GPIO_Pin_5);

	TIM_TimeBaseStructInit(&tim);						//Przerwanie od timera co 10 us
	tim.TIM_CounterMode = TIM_CounterMode_Up;
	tim.TIM_Prescaler = 64 - 1;
	tim.TIM_Period = 10 - 1;
	TIM_TimeBaseInit(TIM2, &tim);

	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
	TIM_Cmd(TIM2, ENABLE);

	//Ustawienie rozdzielczosci kroku na 1/8
	GPIO_SetBits(GPIOC, GPIO_Pin_9);					//M1
	GPIO_SetBits(GPIOB, GPIO_Pin_8);					//M2
	GPIO_ResetBits(GPIOB, GPIO_Pin_9);					//M3

	up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);			//czytanie wartosci krancowek na wszelki wypadek
	down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
	front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
}

void exti_init()
{
	EXTI_InitTypeDef exti;
	NVIC_InitTypeDef nvic;

	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource15);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource14);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource12);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource11);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource10);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource8);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource7);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource6);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource5);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource3);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource1);
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);

	EXTI_StructInit(&exti);
	exti.EXTI_Line = EXTI_Line15;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line14;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line13;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line12;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line11;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line10;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line8;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line7;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line6;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line5;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line3;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line2;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line1;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	exti.EXTI_Line = EXTI_Line0;
	exti.EXTI_Mode = EXTI_Mode_Interrupt;
	exti.EXTI_Trigger = EXTI_Trigger_Falling;
	exti.EXTI_LineCmd = ENABLE;
	EXTI_Init(&exti);

	 nvic.NVIC_IRQChannel = TIM2_IRQn;
	 nvic.NVIC_IRQChannelPreemptionPriority = 0;
	 nvic.NVIC_IRQChannelSubPriority = 0;
	 nvic.NVIC_IRQChannelCmd = ENABLE;
	 NVIC_Init(&nvic);

	nvic.NVIC_IRQChannel = EXTI15_10_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0x02;
	nvic.NVIC_IRQChannelSubPriority = 0x00;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);

	nvic.NVIC_IRQChannel = EXTI9_5_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0x01;
	nvic.NVIC_IRQChannelSubPriority = 0x00;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);

	nvic.NVIC_IRQChannel = EXTI3_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0x00;
	nvic.NVIC_IRQChannelSubPriority = 0x00;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);

	nvic.NVIC_IRQChannel = EXTI2_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0x00;
	nvic.NVIC_IRQChannelSubPriority = 0x00;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);

	nvic.NVIC_IRQChannel = EXTI1_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0x01;
	nvic.NVIC_IRQChannelSubPriority = 0x00;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);

	nvic.NVIC_IRQChannel = EXTI0_IRQn;
	nvic.NVIC_IRQChannelPreemptionPriority = 0x01;
	nvic.NVIC_IRQChannelSubPriority = 0x00;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&nvic);
}

//Deklaracje funkcji wlasnych

void on_off_button();									//przycisk wlaczenia drukarki i obsluga flag ASF
void turn_on();										//wlaczenie drukarki Epson
void turn_off();										//wylaczenie drukarki Epson
void z_up_button_fun();								//funkcja jazdy przyciskiem w gore
void z_down_button_fun();								//funkcja jazdy przyciskiem w dol
void laser_fun();									//funkcja lasera
void y_front_button_fun();								//funkcja jazdy przyciskiem front
void y_home_button_fun();							//funkcja jazdy przyciskiem home
void printing();										//funkcja druku

int main(void)
{
	for (int i = 0; i < 6000000; i++);		//opoznienie startu programu, aby cala inicjalizacja odbywala sie przy stanach ustalonych na wejsciach
	gpio_init();
	exti_init();

	while (1)
	{
		on_off_button();
		if ( print_state == 1)												//jesli drukarka jest wlaczona
		{
			turn_on();
			printing();
		}
		if (print_state == 0)												//wylaczenie drukarki wraz ze sprawdzeniem stanu krancowek
		{
			turn_off();
		}

		//czesc Z - jazda do krancowki przy wcisnietym przycisku

		if ((up_end == 0) && (z_up_but == 0))
		{
			z_up_button_fun();
		}

		if (laser_flag == 1 && up_end == 0)
		{
			laser_fun();
		}

		if (laser_flag == 0)
		{
			z_down_button_fun();
		}

		//przyciski y  - wcisniecie przycisku powoduje ze stol jedzie do krancowki lub do momentu nacisniecia przycisku stop

		if (y_front_but == 0 && front_end == 0 && counter>20000)
		{
			y_front_button_fun();
		}
		if (y_home_but == 0 && home_end == 0 && counter> 20000)
		{
			y_home_button_fun();
		}

		stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
	}
}

//Definicje funkcji wlasnych

void on_off_button()
{
	if(timer_on == 0)											//zeruje wartosci flag i zmienia stan drukarki
	{
		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_1) == 0 && print_state == 0)
		{
			print_state = 1;
			GPIO_SetBits(GPIOC, GPIO_Pin_10);
			counter = 0;
			encoder_flag = 0;
			ASF_flag = 0;
			oldEncoder = 0;
		}
		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_1) == 1 && print_state == 1)
		{
			print_state = 0;
			GPIO_ResetBits(GPIOC, GPIO_Pin_10);
			counter = 0;
			encoder_flag = 0;
			ASF_flag = 0;
			oldEncoder = 0;
		}
	}
	if (ASF_flag == 3 && timer_ASF == 0)						//zeruje ASF
	{
		if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == 1)
		{
			ASF_flag = 0;
		}
		else
			ASF_flag = 1;
	}
}

void turn_on()
{
	if (turn_flag == 0)
	{
		up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);						//sprawdzenie stanu krancowek
		down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
		if(front_end == 1)														//jesli stol znajduje sie na krancowce front
		{
			GPIO_SetBits(GPIOA, GPIO_Pin_12);									//obniz drukarke przez 2s (lub do lasera/krancowki/czujnika odleglosci)
			timer_ms = 2000;
			while(timer_ms != 0 && laser_flag == 0 && down_end == 0)
			{
				laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
			}
			GPIO_ResetBits(GPIOA, GPIO_Pin_12);
		}

		if(home_end == 0)														//powolny start
		{
			GPIO_SetBits(GPIOD, GPIO_Pin_6);
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition--;
			stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
			front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		}
		oldStepper = stepperPosition;
		while(home_end == 0 && (oldStepper - stepperPosition < 3000))							//jazda na home lub 3000 krokow
		{
			if (laser_flag == 0 && z_up_but == 1 && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == 1)
			{
				if(timer_ms == 0)
				{
					GPIO_SetBits(GPIOD, GPIO_Pin_6);
					GPIO_SetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					GPIO_ResetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					stepperPosition--;
				}
			}
			else if (up_end == 0)
			{
				GPIO_SetBits(GPIOA, GPIO_Pin_11);
				while(laser_flag == 1 && up_end == 0)
				{
					laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
				}
				delay(20);
				GPIO_ResetBits(GPIOA, GPIO_Pin_11);
				timer_ms = 100;
			}
		}
		if(stepperPosition >= 0)
		{
			GPIO_SetBits(GPIOD, GPIO_Pin_6);										//powolny stop
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition--;
		}

		GPIO_SetBits(GPIOC, GPIO_Pin_12);									//nadanie sygnalu wlaczenia drukarki
		delay(500);
		GPIO_ResetBits(GPIOC, GPIO_Pin_12);
		counter = 0;
		encoder_flag = 0;
		ASF_flag = 0;
		turn_flag = 1;

		if(home_end == 0)													//powolny start
		{
			GPIO_SetBits(GPIOD, GPIO_Pin_6);
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition--;
			stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
			front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		}
		while(home_end == 0)										//jazda na pozycje home wraz ze sprawdzaniem lasera
		{
			if (laser_flag == 0 && z_up_but == 1)
			{
				if(timer_ms == 0)
				{
					GPIO_SetBits(GPIOD, GPIO_Pin_6);
					GPIO_SetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					GPIO_ResetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					stepperPosition--;
				}
			}
			else if (up_end == 0)
			{
				GPIO_SetBits(GPIOA, GPIO_Pin_11);
				while(laser_flag == 1 && up_end == 0)
				{
					laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
				}
				delay(20);
				GPIO_ResetBits(GPIOA, GPIO_Pin_11);
				timer_ms = 100;
			}
		}
		if(stepperPosition >= 0)
		{
			GPIO_SetBits(GPIOD, GPIO_Pin_6);										//powolny stop
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition--;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition--;
		}
	}
}

void turn_off()
{
	if (turn_flag == 1)
	{
		up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);				//sprawdzenie krancowek
		down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);

		GPIO_SetBits(GPIOC, GPIO_Pin_12);								//nadanie sygnalu na wlacznik Epson
		delay(500);
		GPIO_ResetBits(GPIOC, GPIO_Pin_12);
		turn_flag = 0;

		if(front_end == 0)												//powolny start do front
		{
			GPIO_ResetBits(GPIOD, GPIO_Pin_6);
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition++;
			stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
			front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		}
		while(front_end == 0)													//jazda z laserem
		{
			if (laser_flag == 0 && z_up_but == 1)
			{
				if(timer_ms == 0)
				{
					GPIO_ResetBits(GPIOD, GPIO_Pin_6);
					GPIO_SetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					GPIO_ResetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					stepperPosition++;
				}
			}
			else if (up_end == 0)
			{
				GPIO_SetBits(GPIOA, GPIO_Pin_11);
				while(laser_flag == 1 && up_end == 0)
				{
					laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
				}
				GPIO_ResetBits(GPIOA, GPIO_Pin_11);
				timer_ms = 100;
			}
		}
		if(stepperPosition <= stepMAX)									//powolny stop
		{
			GPIO_ResetBits(GPIOD, GPIO_Pin_6);
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*10);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*10);
			stepperPosition++;
		}
	}
}

void z_up_button_fun()
{
	GPIO_SetBits(GPIOA, GPIO_Pin_11);
	while((up_end == 0) && (z_up_but == 0) && stop_but == 1)
	{
		if(timer_ms3 == 0)
		{
			while((up_end == 0) && stop_but == 1 && z_down_but == 1)
			{
				if(z_up_but == 1)
				{
					but_flag = 1;
				}
				if (z_up_but == 0 && but_flag == 1)
				{
					break;
				}
			}
			but_flag = 0;
			break;
		}
	}
	GPIO_ResetBits(GPIOA, GPIO_Pin_11);
	up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);
	down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
	front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
	y_front_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
	y_home_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);
	z_up_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15);
	z_down_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14);
	stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
}

void z_down_button_fun()
{
	if ((down_end == 0) && (z_down_but == 0) && stepperPosition> 6500)
	{
		GPIO_SetBits(GPIOA, GPIO_Pin_12);
		while((down_end == 0) && (z_down_but == 0) && (laser_flag == 0) && stop_but == 1)
		{
			laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
			if(timer_ms3 == 0)
			{
				while(down_end == 0 && stop_but == 1 && laser_flag == 0 && z_up_but == 1)
				{
					if(z_down_but == 1)
					{
						but_flag = 1;
					}
					if (z_down_but == 0 && but_flag == 1)
					{
						break;
					}
					laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
				}
				but_flag = 0;
				break;
			}
		}
		GPIO_ResetBits(GPIOA, GPIO_Pin_12);
		up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);
		down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
		y_front_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
		y_home_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);
		z_up_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15);
		z_down_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14);
		stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
	}
}

void laser_fun()
{
	GPIO_SetBits(GPIOA, GPIO_Pin_11);
	while(laser_flag == 1 && up_end == 0)
	{
		laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
	}
	GPIO_ResetBits(GPIOA, GPIO_Pin_11);
	delay(100);
	z_down_but = 1;
}

void y_front_button_fun()
{
	if(front_end == 0 && stop_but == 1)
	{
		GPIO_ResetBits(GPIOD, GPIO_Pin_6);
		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*8);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*8);
		stepperPosition++;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*6);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*6);
		stepperPosition++;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*5);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*5);
		stepperPosition++;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*4);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*4);
		stepperPosition++;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*3);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*3);
		stepperPosition++;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*2);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*2);
		stepperPosition++;
		stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	}
	while(front_end == 0 && stop_but == 1)
	{
		if (laser_flag == 0 && z_up_but == 1)
		{
			if(timer_ms == 0)
			{
				GPIO_ResetBits(GPIOD, GPIO_Pin_6);
				GPIO_SetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok_home);
				GPIO_ResetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok_home);
				stepperPosition++;
				stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
				front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
			}
		}
		else if (up_end == 0)
		{
			GPIO_SetBits(GPIOA, GPIO_Pin_11);
			while(laser_flag == 1 && up_end == 0 && z_up_but == 0)
			{
				laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
			}
			delay(10);
			GPIO_ResetBits(GPIOA, GPIO_Pin_11);
			timer_ms = 100;
		}
	}

	GPIO_ResetBits(GPIOD, GPIO_Pin_6);
	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*2);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*2);
	stepperPosition++;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*3);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*3);
	stepperPosition++;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*4);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*4);
	stepperPosition++;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*5);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*5);
	stepperPosition++;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*6);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*6);
	stepperPosition++;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*8);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*8);
	stepperPosition++;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*10);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*10);
	stepperPosition++;

	if(stepperPosition % 2 == 1)
	{
		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*12);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*12);
		stepperPosition++;
	}

	if(stepperPosition % 4 == 0)
	{
		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*14);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*14);
		stepperPosition++;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*16);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*16);
		stepperPosition++;
	}

	up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);
	down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
	front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
	y_front_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
	y_home_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);
	z_up_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15);
	z_down_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14);
	stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
}

void y_home_button_fun()
{
	while(y_home_but == 0);
	if(front_end == 1)
	{
		GPIO_SetBits(GPIOA, GPIO_Pin_12);
		timer_ms = 2000;
		while(timer_ms != 0 && laser_flag == 0 && (down_end == 0))
		{
			laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
		}
		GPIO_ResetBits(GPIOA, GPIO_Pin_12);
	}

	if(home_end == 0)
	{
		GPIO_SetBits(GPIOD, GPIO_Pin_6);
		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*8);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*8);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*6);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*6);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*5);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*5);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*4);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*4);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*3);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*3);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*2);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*2);
		stepperPosition--;
		stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	}
	oldStepper = stepperPosition;
	while(home_end == 0 && (oldStepper - stepperPosition < 3000) && stop_but == 1)										//jazda na pozycje home wraz ze sprawdzaniem lasera
	{
		if (laser_flag == 0 && z_up_but == 1 && GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == 1)
		{
			if(timer_ms == 0)
			{
				GPIO_SetBits(GPIOD, GPIO_Pin_6);
				GPIO_SetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok_home);
				GPIO_ResetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok_home);
				stepperPosition--;
			}
		}
		else if (up_end == 0)
		{
			GPIO_SetBits(GPIOA, GPIO_Pin_11);
			while(laser_flag == 1 && up_end == 0)
			{
				laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
			}
			delay(20);
			GPIO_ResetBits(GPIOA, GPIO_Pin_11);
			timer_ms = 100;
		}
	}
	GPIO_SetBits(GPIOD, GPIO_Pin_6);
	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*2);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*2);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*3);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*3);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*4);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*4);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*5);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*5);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*6);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*6);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*8);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*8);
	stepperPosition--;

	if(home_end == 0 && stop_but == 1)
	{
		GPIO_SetBits(GPIOD, GPIO_Pin_6);
		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*8);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*8);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*6);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*6);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*5);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*5);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*4);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*4);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*3);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*3);
		stepperPosition--;

		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*2);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*2);
		stepperPosition--;
		stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	}
	while(home_end == 0 && stop_but == 1)
	{
		if (laser_flag == 0 && z_up_but == 1)
		{
			if(timer_ms == 0)
			{
				GPIO_SetBits(GPIOD, GPIO_Pin_6);
				GPIO_SetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok_home);
				GPIO_ResetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok_home);
				stepperPosition--;
				stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
				home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
			}
		}
		else if (up_end == 0)
		{
			GPIO_SetBits(GPIOA, GPIO_Pin_11);
			while(laser_flag == 1 && up_end == 0 && z_up_but == 0)
			{
				laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
			}
			delay(20);
			GPIO_ResetBits(GPIOA, GPIO_Pin_11);
			timer_ms = 100;
		}
	}
	GPIO_SetBits(GPIOD, GPIO_Pin_6);
	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*2);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*2);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*3);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*3);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*4);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*4);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*5);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*5);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*6);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*6);
	stepperPosition--;

	GPIO_SetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*8);
	GPIO_ResetBits(GPIOD, GPIO_Pin_7);
	delay_us(rozdz_krok*8);
	stepperPosition--;

	if(stepperPosition % 2 == 1)
	{
		GPIO_SetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*10);
		GPIO_ResetBits(GPIOD, GPIO_Pin_7);
		delay_us(rozdz_krok*10);
		stepperPosition--;
	}

	up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);
	down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
	front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
	home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
	y_front_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12);
	y_home_but = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);
	z_up_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_15);
	z_down_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_14);
	stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
}

void printing()
{
	if(ASF_flag == 1 && encoder_flag == 3 && home_end == 1)							//start druku
	{
		ASF_flag = 2;												//ustawienie sygnalu ASF
		delay(849);
		GPIO_SetBits(GPIOC, GPIO_Pin_0);
		GPIO_SetBits(GPIOA, GPIO_Pin_5);
		ASF_flag = 1;
		encoderPosition = 0;
		up_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5);
		down_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_6);
		front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		home_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3);
		if(front_end == 0)
		{
			GPIO_ResetBits(GPIOD, GPIO_Pin_6);
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition++;
			stop_but = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
			front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
		}
		while(stepperPosition<start_pos)							//ruch na pozycje poczatkowa
		{
			if (laser_flag == 0 && z_up_but == 1)
			{
				GPIO_ResetBits(GPIOD, GPIO_Pin_6);
				GPIO_SetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok);
				GPIO_ResetBits(GPIOD, GPIO_Pin_7);
				delay_us(rozdz_krok);
				stepperPosition++;
			}
			else if (up_end == 0)
			{
				GPIO_SetBits(GPIOA, GPIO_Pin_11);
				while(laser_flag == 1 && up_end == 0);
				GPIO_ResetBits(GPIOA, GPIO_Pin_11);
			}
		}
		while(front_end == 0 && encoderPosition < 90000)		//po osiagnieciu 6241 krokow lub krancowki przerywa petle
		{
			if (encoder_flag == 5 && encoderPosition != oldEncoder)	//przeliczenie impulsow enkodera na pozycje silnika z uwzglednieniem pozycji poczatkowej
			{
				stepperCount = (encoderPosition/stepperFactor)+start_pos;
				oldEncoder = encoderPosition;
			}
			if (stepperCount > stepperPosition)						//ruch do przeliczonej pozycji
			{
				if (laser_flag == 0 && z_up_but == 1)
				{
					GPIO_ResetBits(GPIOD, GPIO_Pin_6);
					GPIO_SetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok);
					GPIO_ResetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok);
					stepperPosition++;
				}
				else if (up_end == 0)
				{
					GPIO_SetBits(GPIOA, GPIO_Pin_11);
					while(laser_flag == 1 && up_end == 0)
					{
						laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
					}
					delay(20);
					GPIO_ResetBits(GPIOA, GPIO_Pin_11);
				}
			}
		}
		GPIO_ResetBits(GPIOC, GPIO_Pin_0);							//nadanie sygnalu konca papieru
		GPIO_ResetBits(GPIOA, GPIO_Pin_5);
		while(front_end == 0)										//dalsza jazda - najpierw do ostatecznej pozycji wynikajacej z enkodera, a po 5s jego bezruchu do krancowki
		{
			if (encoder_flag == 5 && encoderPosition != oldEncoder)	//ruch silnika Y po przeliczeniu impulsow enkodera
			{
				stepperCount = (encoderPosition/stepperFactor)+start_pos;
				oldEncoder = encoderPosition;
			}
			if (stepperCount > stepperPosition)
			{
				if (laser_flag == 0 && z_up_but == 1)
				{
					GPIO_ResetBits(GPIOD, GPIO_Pin_6);
					GPIO_SetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					GPIO_ResetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					stepperPosition++;
				}
				else if (up_end == 0)
				{
					GPIO_SetBits(GPIOA, GPIO_Pin_11);
					while(laser_flag == 1 && up_end == 0)
					{
						laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
					}
					GPIO_ResetBits(GPIOA, GPIO_Pin_11);
				}
			}
			if(timer_enc == 0)
			{
				front_end = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
				if (laser_flag == 0 && z_up_but == 1)
				{
					GPIO_ResetBits(GPIOD, GPIO_Pin_6);
					GPIO_SetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					GPIO_ResetBits(GPIOD, GPIO_Pin_7);
					delay_us(rozdz_krok_home);
					stepperPosition++;
				}
				else if (up_end == 0)
				{
					GPIO_SetBits(GPIOA, GPIO_Pin_11);
					while(laser_flag == 1 && up_end == 0)
					{
						laser_flag = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10);
					}
					delay(20);
					GPIO_ResetBits(GPIOA, GPIO_Pin_11);
				}
			}
		}
		if(encoder_flag !=3)
		{
			GPIO_ResetBits(GPIOD, GPIO_Pin_6);
			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*2);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*3);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*4);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*5);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*6);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*8);
			stepperPosition++;

			GPIO_SetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*10);
			GPIO_ResetBits(GPIOD, GPIO_Pin_7);
			delay_us(rozdz_krok*10);
			stepperPosition++;
			encoder_flag = 3;
		}
	}
}

#ifdef  USE_FULL_ASSERT

/**
* @brief  Reports the name of the source file and the source line number
*         where the assert_param error has occurred.
* @param  file: pointer to the source file name
* @param  line: assert_param error line source number
* @retval None
*/
void assert_failed(uint8_t* file, uint32_t line)
{
  /* User can add his own implementation to report the file name and line number,
  ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/**
* @}
*/


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
